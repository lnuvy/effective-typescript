## 6) 편집기를 사용하여 타입 시스템 탐색하기

타입스크립트를 설치하면 두가지를 실행할 수 있다.

1. 타입스크립트 컴파일러 (tsc)
2. 단독으로 실행할 수 있는 타입스크립트 서버 (tsserver)

컴파일 뿐만 아니라, tsserver 는 언어 서비스를 제공한다는 점에서 중요한 대목이다.

```javascript
function logMessage(message: string | null) {
  if (message) {
    // 여기서의 파라미터 message는 string 타입임을 자동으로 추론해준다.
    console.log(message);
  } else {
    // 이 조건문 안의 message 는 반드시 null 타입임을 추론해준다.
    console.log(null === message); // true
  }
}
```

<br />

자바스크립트 내장함수인 fetch 함수에 커서를 두면 타입들을 확인해볼 수 있는데, `lib.dom.d.ts` 로 이동해보면 다음과 같은 타입을 볼 수 있다.

```javascript
declare function fetch(
  input: RequestInfo | URL,
  init?: RequestInit
): Promise<Response>;
```

RequestInfo 에 타고 가보면

```javascript
type RequestInfo = Request | string;
```

<br />

<details>
<summary style="cursor: pointer">RequestInit 를 타고 가보면 (스압주의)</summary>
<div markdown="1">

```javascript
interface RequestInit {
  /** A BodyInit object or null to set request's body. */
  body?: BodyInit | null;
  /** A string indicating how the request will interact with the browser's cache to set request's cache. */
  cache?: RequestCache;
  /** A string indicating whether credentials will be sent with the request always, never, or only when sent to a same-origin URL. Sets request's credentials. */
  credentials?: RequestCredentials;
  /** A Headers object, an object literal, or an array of two-item arrays to set request's headers. */
  headers?: HeadersInit;
  /** A cryptographic hash of the resource to be fetched by request. Sets request's integrity. */
  integrity?: string;
  /** A boolean to set request's keepalive. */
  keepalive?: boolean;
  /** A string to set request's method. */
  method?: string;
  /** A string to indicate whether the request will use CORS, or will be restricted to same-origin URLs. Sets request's mode. */
  mode?: RequestMode;
  /** A string indicating whether request follows redirects, results in an error upon encountering a redirect, or returns the redirect (in an opaque fashion). Sets request's redirect. */
  redirect?: RequestRedirect;
  /** A string whose value is a same-origin URL, "about:client", or the empty string, to set request's referrer. */
  referrer?: string;
  /** A referrer policy to set request's referrerPolicy. */
  referrerPolicy?: ReferrerPolicy;
  /** An AbortSignal to set request's signal. */
  signal?: AbortSignal | null;
  /** Can only be null. Used to disassociate request from any Window. */
  window?: null;
}
```

</div>
</details>
<br />

#### 요약

1. 편집기에서 타입스크립트 언어 서비스를 적극 활용해야한다.
2. 편집기를 사용하면 어떻게 타입 시스템이 동작하는지, 그리고 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡기 쉽다.
3. 타입스크립트가 동작을 모델링하는지 알기 위해 타입 선언 파일을 찾아보는 방법을 익히는 것이 좋다.

## 7) 타입이 값들의 집합이라고 생각하기

모든 변수는 런타임에서는 각자의 고유한 값을 가지고 있다.
하지만 코드가 실행되기 전, 즉 타입스크립트가 오류를 체크하는 순간에는 '타입'을 가지고 있다.
책에서는 '**타입은 할당 가능한 값들의 집합(범위)**' 라고 이해해야 한다고 강조하고 있다.

가장 작은 범위의 집합부터 차근차근 진행해보자.

> ### `never` 타입
>
> ```javascript
> const x: never = 12;
> // Type 'number' is not assignable to type 'never'.ts(2322)
> ```
>
> 집합에서 가장 작은 집합은 공집합이다. 타입스크립트에서의 `never` 타입이 공집합에 해당하는 셈이다.

<br />

> ### `unit/literal` 타입
>
> ```javascript
> type A = "A";
> type Ten = 10;
>
> type AorB = "A" | "B";
> type AB12 = "A" | "B" | 12;
>
> const a: AB12 = "A"; // ok
> const c: AB12 = "C";
> // Type '"C"' is not assignable to type 'AB12'.ts(2322)
> ```
>
> 한가지 값만 포함하는 타입을 유닛(unit) 타입, 혹은 리터럴(literal) 타입이라 한다.  
> 두 개, 세 개, ... 여러개로 묶을땐 유니온(union) 기호를 사용한다. 유니온 타입은 값 집합들의 합집합을 의미한다.

<br />

### 본격적으로 범위 지정해보기 with `type/interface`

```javascript
interface Identified {
  id: string;
}
```

위 코드가 선언 되었다면, 어떤 객체가 string 이 할당된 id 속성을 가지고 있다면 그 객체는 Identified 객체이다.(1장에서의 덕 타이핑, 구조적 타이핑을 떠올린다면 당연한 명제이다.)

다음 예제를 보자.

```javascript

```

```javascript
interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}

type PersonSpan = Person & Lifespan;
```

& 연산자는 두 타입의 인터섹션(intersection) 즉, 교집합을 계산한다.
여기서 중요한것은 교집합으로 인한 공집합이 아니라는 것이다.

Person 속성과 Lifespan 속성을 둘다 포함하는 객체는 옳은 타입이다.

```javascript
const ps: PersonSpan = {
  name: "asdf",
  birth: new Date("2000/01/01"),
  death: new Date("2022/01/01"), // optional
};
// ok
```

알아둘 점은 속성에 대한 인터섹션은 맞지만, 두 인터페이스의 유니온은 타입이 never 로 된다는 점이다.

```javascript
  type K = keyof (Person | Lifespan); // 타입 never
```

일반적으로는 extends 키워드로 상속시키는 것이 좋다.

```javascript
interface Person {
  name: string;
}
interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}
```

'서브타입'이란, 어떤 집합이 다른 집합의 부분 집합이라는 뜻이다.
아래의 예시를 통해 알아보자.

```javascript
interface Vector1D {
  x: number;
}
interface Vector2D extends Vector1D {
  y: number;
}
interface Vector3D extends Vector2D {
  z: number;
}
```

Vector3D 는 Vector2D 의 서브타입이고, Vector2D 는 Vector1D 의 서브타입이다. 클래스에서도 똑같이 적용된다.

```javascript
interface Point {
  x: number;
  y: number;
}

type PointKeys = keyof Point; // x | y

function sortBy<K extends keyof T, T>(vals: T[], key: K): T[] {
  // ...
}

const pts: Point[] = [{x: 1, y:1}, {x: 2, y: 0}]
sortBy(pts, 'x')
sortBy(pts, 'y')
sortBy(pts, Math.random() < 0.5 ? 'x':'y')
sortBy(pts, 'z') // Argument of type '"z"' is not assignable to parameter of type 'keyof Point'.ts(2345)

```

#### 요약

1. 타입을 밧의 집합으로 생각하면 이해하기 쉽다. 이 집합은 유한(boolean 또는 리터럴)하거나 무한(number 또는 string 등) 하다.
2. 타입스크립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는 집합으로 표현된다.
3. 타입 연산은 집합의 범위에 적용된다. 객체 타입에서 A & B 일때, A와 B의 속성을 모두 가짐을 의미한다.
4. 'A는 B를 상속한다', 'A는 B에 할당 가능하다', 'A는 B의 서브타입이다' 는 모두 'A는 B의 부분집합이다' 라는 의미이다.

## 8) 타입 공간과 값 공간의 심벌 구분하기

이번 아이템에서는 타입스크립트의 심벌(symbol)이 타입 공간과 값 공간 두 공간에 모두 존재 할 수 있다는 점을 강조하고있다.

```javascript
type T1 = "string literal";
type T2 = 123;
const T1 = "string literal";
const T2 = 123;
```

여기서는 상단 type 으로 선언된 T1과 T2는 타입, const 로 선언된 심벌은 값이다.
두 공간은 명확히 다르다는 점을 인지하는것이 중요하다.  
교재에서는 두 공간에 대한 개념을 잡을 때 도움 되는 사이트로 타입스크립트 플레이그라운드를 추천하고 있다.

> [타입스크립트 플레이그라운드 링크](https://www.typescriptlang.org/play)

위의 소스코드처럼 직관적으로 공간을 나눌 수 있고, 역시 자주 사용하는 as 나 : 으로 타입을 선언한 심벌은 타입이고 = 다음에 나오는 모든 것은 값이다.

단일객체 매개변수를 받는 email 함수가 있다고 할 때,

```javascript
interface Person {
  // ...
}

function email(options: { person: Person, subject: string, body: string }) {
  // ...
}
```

위와같은 함수는 js에서 구조 분해 할당(destructuring) 을 사용할 수 있다.

```javascript
function email({ person, subject, body }) {
  // ...
}
```

위 코드는 타입스크립트환경에서 아래와 같은 오류를 뱉는다.  
 `Binding element '(변수명)' implicitly has an 'any' type.(7031)`

타입 관점이 아닌 값의 관점에서 매개변수들이 해석되었기 때문이다. 문제를 해결하기 위해선 아래와 같이 타입과 값을 구분해 줄 필요가 있다.

```javascript
function email({
  person,
  subject,
  body,
}: {
  person: Person,
  subject: string,
  body: string,
}) {
  // ...
}
```

#### 요약

1. 타입스크립트 코드를 읽을 때 타입인지 값인지 구분하는 연습이 필요하다.
2. 모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다.
3. class, enum 같은 키워드는 타입과 값 두 가지로 사용될 수 있다.
4. typeof, this, 다른 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.

## 9) 타입 단언보다는 타입 선언을 사용하기

```javascript
//타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법
  interface Person {name: string};

  const alice: Person = {name: 'Alice'};
  const bob = {name: 'Bob'} as Person;
```

첫번째는 :(타입 선언)을 사용했고 두번째는 as(타입 단언)을 사용했다.
교재에서는 타입 단언보다 타입 선언을 사용하는 것이 좋고, 그 이유에 대해 아래와 같이 설명한다.

```javascript
  const alice: Person = {}; // error
  // Property 'name' is missing in type '{}' but required in type 'Person'.(2741)
  const bob = {} as Person; // ok

  const alice: Person = {
    name: 'Alice',
    occupation: 'Typescript developer' // error
  };
  // Type '{ name: string; occupation: string; }' is not assignable to type 'Person'. Object literal may only specify known properties, and 'occupation' does not exist in type 'Person'.(2322)

  const bob = {
    name: 'Bob',
    occupation: 'Javascript developer'
  } as Person; // ok
```

타입 단언은 강제로 타입을 지정하게되어 타입 체커에서 오류를 무시하라고 지시하는 것과 같다.  
그렇다면 타입 단언은 언제 사용하면 좋을까? 바로 '타입 체커가 추론하는 타입보다 개발자가 판단하는 타입이 더 정확할 때' 이다.
교재에서는 DOM 엘리먼트를 예시로 들고있다.

```javascript
  document.querySelector('#myButton')!.addEventListener('click', (e) => {
    e.currentTarget // 타입은 EventTarget
    const button = e.currentTarget as HTMLButtonElement;
    button // 타입은 HTMLButtonElement
  })
```

타입스크립트는 DOM에 접근할 수 없기 때문에 `#myButton` 이 버튼 엘리먼트인지 알 수 없다. 그리고 이벤트의 `currentTarget` 이 같은 버튼인 것도 알 수 없다. 이럴때는 타입단언문을 사용하는것이 좋은 사용법이 될 것이다.

위 예시에서 사용한 것처럼 접미사에 붙은 `!` 는 해당 값이 null 이 아니라는 단언문이라는 것도 짚고 넘어가자.

#### 요약

1. 타입 단언(as)보다 타입 선언(:)을 사용하는 것이 좋다.
2. 화살표 함수의 반환 타입을 명시하는 방법을 터득해야한다.
3. 타입스크립트보다 타입 정보를 더 잘 알고 있을때, 타입 단언문과 ! 를 활용하자.

## 10) 객체 래퍼 타입 피하기

자바스크립트에는 객체 이외의 기본형 값들에 대한 7가지 타입이 존재한다.

- string
- number
- boolean
- null
- undefined
- symbol
- bigint

객체와 다르게 기본형들은 불변성(immutable)과 메서드를 가지지 않는다는 차이점이 있다.

```javascript
"string".charAt(3); // "i"
"string".slice(1); // "tring"
```

이런 메서드들을 잘 이용해오던 사람들이라면 '메서드를 가지지 않는다고?' 라고 의문이 생길 수 있다. 하지만 위와 같은 메서드들을 자유롭게 사용할 수 있는 이유는 자바스크립트에 있는 String 래퍼 객체가 있기 때문이다.
자바스크립트는 기본형 string 을 String 객체로 래핑하고 메서드를 호출한 뒤, 래핑한 객체를 버린다.

string 뿐만 아니라 `null` 과 `undefined` 를 제외한 5개의 타입은 모두 객체 래퍼 타입이 존재한다.

그럼 타입 선언을 래퍼 객체로 하게되면 발생하는 문제점에 대해 알아보자.

```javascript
// 매개변수로 String 객체 메서드를 사용하지 않을때는 정상적으로 작동하는 것 처럼 보인다.
function getStringLen(foo: String) {
  return foo.length; // ok
}

function isGreeting(phrase: String) {
  return ["hello", "good day"].includes(phrase);
  // Argument of type 'String' is not assignable to parameter of type 'string'. 'string' is a primitive, but 'String' is a wrapper object. Prefer using 'string' when possible.(2345)
}
```

오류문에서 알 수 있듯이 `String` 은 `string` 에 할당할 수 없다. 매개변수의 타입을 `string` 으로 바꾸면 해결된다.

타입스크립트가 제공하는 타입 선언은 전부 기본형으로 되어 있기 때문에, 기본형 타입을 객체 래퍼에 할당하는 구문은 오해만 일으키고 굳이 그렇게 할 필요가 없다.(위와 같이 오히려 제한되는 상황만 있고, 이점이 없기 때문)  
예외적으로, new 키워드 없이 BigInt 와 Symbol 을 호출하는 경우는 기본형을 생성한다고 한다. 이런 경우는 래퍼 타입을 사용해도 문제는 없다. ~~(하지만 굳이?)~~

#### 요약

1. 기본형 값에 메서드를 제공하기 위해 객체 래퍼 타입이 어떻게 쓰이는지 이해해야한다.
2. 객체 래퍼 타입 선언은 지양하고, 기본형 타입을 사용해야 한다.

## 11) 잉여 속성 체크의 한계 인지하기
